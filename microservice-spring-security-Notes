#############################################
ðŸ” Core Features of Spring Security:
##############################################
1. Authentication: Verifies who you are (e.g., username & password, JWT etc.).

2. Authorization: Determines what you are allowed to do (e.g., access control for URLs, methods, etc.).

3. Protection Against Common Security Threats

a. CSRF (Cross-Site Request Forgery)
--------------------------------------
1. ðŸ›¡ CSRF (Cross-Site Request Forgery)
What it is:
An attacker tricks a logged-in user into unknowingly sending a request (like transferring money or changing a password) to your application.

Example:

-> You're logged into yourbank.com.
-> An attacker sends you a malicious link:
-> <img src="https://yourbank.com/transfer?to=attacker&amount=1000" />
-> If your session is still active, your browser might execute this without your intent.
-> Spring Security Protection:
-> Automatically adds a CSRF token to every form and expects it in requests. 
-> In a web application that uses Spring Security, the CSRF token is automatically added as a hidden input field inside HTML forms.
-> Blocks requests without valid tokens.



2. ðŸ”’ Session Fixation
------------------------------------
What it is:
An attacker sets a known session ID for a user, then waits for the user to log in. If successful, the attacker reuses the same session.

Example:
-> Attacker sends a link with a fixed session ID:
-> https://example.com/login;jsessionid=abc123
-> User logs in; attacker now hijacks the session with abc123.
-> Spring Security Protection:
-> Regenerates the session ID after successful login by default (prevents reuse).

To Enable we do this: http.sessionManagement().sessionFixation().migrateSession();  // default behavior


3. Clickjacking

-> Here's a simplified explanation of the Clickjacking attack:
-> Attacker's Page: The attacker creates a webpage that hides a legitimate banking website inside an invisible iframe (like a hidden box).
-> User's Interaction: The user thinks they are clicking on a button (e.g., "Play Video" or "Download File") on the attackerâ€™s page.
-> What Happens: In reality, the user is actually clicking on the invisible iframe that contains the banking page. They might unintentionally trigger actions on the banking site, like transferring money or changing their account settings.

4. Brute-Force Attack Example
-> What It Is: A Brute-Force Attack is when an attacker attempts to guess the correct credentials (like a password) by trying many possible combinations until they find the correct one.

Example:
-> The Attacker's Goal: The attacker wants to gain unauthorized access to a user's account, for example, the userâ€™s bank account.

-> How It Works:
-> The attacker knows the username (e.g., "victim123") but not the password.
-> Using automated tools, the attacker repeatedly tries different passwords for the account, for example:
-> Password attempt 1: password123
-> Password attempt 2: 123456
-> Password attempt 3: victim123
-> Password attempt 4: qwerty

And so on, until the correct password is found.

-> How It Looks to the User: The attacker might perform hundreds of thousands or even millions of attempts per second, which can eventually crack weak passwords.

-> Attack's Success: Once the attacker guesses the correct password, they can log into the victimâ€™s account and gain access to sensitive information, such as personal data or financial records.

-> How to Prevent Brute-Force Attacks:

a. Rate Limiting:
Limit the number of failed login attempts within a certain time frame (e.g., 5 attempts per minute). After exceeding this limit, block the IP address or enforce a longer delay before the next attempt.

b. CAPTCHA:
Use CAPTCHA challenges after a certain number of failed login attempts. This helps to ensure that it's a human attempting the login rather than a bot performing automated attacks.

c. Account Lockout:
Temporarily lock an account after a set number of failed login attempts. For example, lock the account for 10 minutes after 5 failed login attempts.

d. Multi-Factor Authentication (MFA):
Use MFA to add an extra layer of security. Even if the attacker manages to guess the password, they will still need access to the second factor (e.g., a phone or hardware token).

e. Strong Passwords:
Encourage users to use strong, unique passwords (e.g., a combination of uppercase, lowercase letters, numbers, and special characters). Use a password strength checker and enforce password complexity rules.

5. Password Handling: Secure password storage using hashing (e.g., BCrypt).

6. Integration with Spring Boot: Auto-configuration with sensible defaults.

7. JWT (JSON Web Token)

 STEPS TO IMPLEMENT SPRING SECURITY :
*****************************************

FOR SINGUP/REGISTRATION :

FOR ROLE-BASED LOGIN :





---------------------------

âœ… 3. Test Using Postman or curl
ðŸ”¹ Test with Postman
Choose GET and enter:
http://localhost:8080/api/v1/admin/welcome

Go to Authorization tab
Type: Basic Auth
Username: admin
Password: admin (assuming that's the encoded password in DB)

Click Send.

You should get a 200 OK and the "Welcome, Admin!" message if the role is correctly configured.
----------------------------------------------------------------------------------------------------------------------

Imnport Notes
############################
Stateless: User details are not stored at the server side. Hence every every request we have to perform authention

Statefull: User details are  stored at the server side. Once the use perform login, Server will generate SessionId, One Copy of session will be kept at server side & another copy is given to the client, so that for subsequent request we can authenticate the user by sending seesionId with the request to server. When session Id matches you will get the respsone

---------------------------------------------------------------------------------

Advantages of JWT Token
#########################
-> Stateless Communication
-> This performs Authentication of subsequent request made post login was successful
-> Highly Secured
-> Set Expiry time for token
-> Securing All Microservice can be made easy with JWT Token

Architecture of JWT Token
###############################
Header.PayLoad.Signature

Explanation of The Architecture

What is header?
Answer: ALGORITHM & TOKEN TYPE

Example:
{
  "alg": "HS256",
  "typ": "JWT"
}

What is PayLoad?
Answer:
-> For which user token is generated (User Details)
-> Who has generated this token (Issuer)
-> Expiry Time Of Token?
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}

What is Signature?
Answer: Secret key 

####################################################
Implementing JWT Token
####################################################

Download the dependency
------------------------
<dependency>
    <groupId>com.auth0</groupId>
    <artifactId>java-jwt</artifactId>
    <version>4.4.0</version>
</dependency>


Create JWTService class
---------------------------
package com.authservice.jwt;

import java.util.Date;
import org.springframework.stereotype.Service;
import com.auth0.jwt.JWT;
import com.auth0.jwt.algorithms.Algorithm;

@Service
public class JwtService {

    private static final String SECRET_KEY = "my-super-secret-key";
    private static final long EXPIRATION_TIME = 86400000; // 1 day

    public String generateToken(String username, String role) {
        return JWT.create()
            .withSubject(username)
            .withClaim("role", role)
            .withIssuedAt(new Date())
            .withExpiresAt(new Date(System.currentTimeMillis() + EXPIRATION_TIME))
            .sign(Algorithm.HMAC256(SECRET_KEY));
    }

    public String validateTokenAndRetrieveSubject(String token) {
        return JWT.require(Algorithm.HMAC256(SECRET_KEY))
            .build()
            .verify(token)
            .getSubject();
    }
}

Modify AuthController  Class
--------------------------------

@Autowired
private JwtService jwtService;

@PostMapping("/login")
public ResponseEntity<APIResponse<String>> loginCheck(@RequestBody LoginDto loginDto) {
    APIResponse<String> response = new APIResponse<>();

    UsernamePasswordAuthenticationToken token = 
        new UsernamePasswordAuthenticationToken(loginDto.getUsername(), loginDto.getPassword());

    try {
        Authentication authenticate = authManager.authenticate(token);
        if (authenticate.isAuthenticated()) {
            String jwtToken = jwtService.generateToken(loginDto.getUsername(),
                authenticate.getAuthorities().iterator().next().getAuthority());

            response.setMessage("Login Successful");
            response.setStatus(200);
            response.setData(jwtToken);  // return JWT
            return new ResponseEntity<>(response, HttpStatusCode.valueOf(response.getStatus()));
        }
    } catch (Exception e) {
        e.printStackTrace();
    }

    response.setMessage("Failed");
    response.setStatus(401);
    response.setData("Unauthorized");
    return new ResponseEntity<>(response, HttpStatusCode.valueOf(response.getStatus()));
}

Develop JWTFilter Class
-----------------------------

package com.authservice.jwt;

import jakarta.servlet.FilterChain;
import jakarta.servlet.ServletException;
import jakarta.servlet.http.HttpServletRequest;
import jakarta.servlet.http.HttpServletResponse;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.security.authentication.UsernamePasswordAuthenticationToken;
import org.springframework.security.core.context.SecurityContextHolder;
import org.springframework.security.web.authentication.WebAuthenticationDetailsSource;
import org.springframework.stereotype.Component;
import org.springframework.web.filter.OncePerRequestFilter;

import com.authservice.service.CustomerUserDetailsService;

import java.io.IOException;

@Component
public class JwtFilter extends OncePerRequestFilter {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private CustomerUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String jwt = authHeader.substring(7);
            String username = jwtService.validateTokenAndRetrieveSubject(jwt);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                var userDetails = userDetailsService.loadUserByUsername(username);
                var authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}

Modify Secuirty Config
---------------------------

import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.context.annotation.Bean;
import org.springframework.context.annotation.Configuration;
import org.springframework.security.authentication.AuthenticationManager;
import org.springframework.security.authentication.AuthenticationProvider;
import org.springframework.security.authentication.dao.DaoAuthenticationProvider;
import org.springframework.security.config.annotation.authentication.configuration.AuthenticationConfiguration;
import org.springframework.security.config.annotation.web.builders.HttpSecurity;
import org.springframework.security.config.annotation.web.configuration.EnableWebSecurity;
import org.springframework.security.crypto.bcrypt.BCryptPasswordEncoder;
import org.springframework.security.crypto.password.PasswordEncoder;
import org.springframework.security.web.SecurityFilterChain;
import org.springframework.security.web.authentication.UsernamePasswordAuthenticationFilter;

import com.authservice.service.CustomerUserDetailsService;
import com.authservice.service.JwtFilter;

@Configuration
@EnableWebSecurity
public class AppSecurityConfig {
	
	@Autowired
	private CustomerUserDetailsService customerUserDetailsService;
	
	@Autowired
	private JwtFilter filter;

    String[] publicEndpoints = {
        "/api/v1/auth/register",
        "/api/v1/auth/login",
        "/api/v1/auth/update-password",
        "/v3/api-docs/**",
        "/swagger-ui/**",
        "/swagger-ui.html",
        "/swagger-resources/**",
        "/webjars/**"
    };

    @Bean
    public PasswordEncoder getEncoder() {
        return new BCryptPasswordEncoder();
    }
    
    @Bean
	public AuthenticationManager authManager(AuthenticationConfiguration config) throws Exception {
		return config.getAuthenticationManager();
	}
    
    @Bean
	public AuthenticationProvider authProvider() {

		DaoAuthenticationProvider authProvider = new DaoAuthenticationProvider();

		authProvider.setUserDetailsService(customerUserDetailsService);
		authProvider.setPasswordEncoder(getEncoder());

		return authProvider;
	}

    @Bean
	public SecurityFilterChain securityConfig(HttpSecurity http) throws Exception{
		
		http.authorizeHttpRequests( req -> {
			req.requestMatchers(publicEndpoints)
			   .permitAll()
			   .requestMatchers("/api/v1/admin/welcome").hasRole("ADMIN")
			   .anyRequest()
			   .authenticated();			
		}) .authenticationProvider(authProvider())
        .addFilterBefore(filter, UsernamePasswordAuthenticationFilter.class);
		
		return http.csrf().disable().build();
	}


}













