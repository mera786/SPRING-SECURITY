#############################################
🔐 Core Features of Spring Security:
##############################################
1. Authentication: Verifies who you are (e.g., username & password, JWT etc.).

2. Authorization: Determines what you are allowed to do (e.g., access control for URLs, methods, etc.).

3. Protection Against Common Security Threats

a. CSRF (Cross-Site Request Forgery)
--------------------------------------
1. 🛡 CSRF (Cross-Site Request Forgery)
What it is:
An attacker tricks a logged-in user into unknowingly sending a request (like transferring money or changing a password) to your application.

Example:

-> You're logged into yourbank.com.
-> An attacker sends you a malicious link:
-> <img src="https://yourbank.com/transfer?to=attacker&amount=1000" />
-> If your session is still active, your browser might execute this without your intent.
-> Spring Security Protection:
-> Automatically adds a CSRF token to every form and expects it in requests. 
-> In a web application that uses Spring Security, the CSRF token is automatically added as a hidden input field inside HTML forms.
-> Blocks requests without valid tokens.



2. 🔒 Session Fixation
------------------------------------
What it is:
An attacker sets a known session ID for a user, then waits for the user to log in. If successful, the attacker reuses the same session.

Example:
-> Attacker sends a link with a fixed session ID:
-> https://example.com/login;jsessionid=abc123
-> User logs in; attacker now hijacks the session with abc123.
-> Spring Security Protection:
-> Regenerates the session ID after successful login by default (prevents reuse).

To Enable we do this: http.sessionManagement().sessionFixation().migrateSession();  // default behavior


3. Clickjacking

-> Here's a simplified explanation of the Clickjacking attack:
-> Attacker's Page: The attacker creates a webpage that hides a legitimate banking website inside an invisible iframe (like a hidden box).
-> User's Interaction: The user thinks they are clicking on a button (e.g., "Play Video" or "Download File") on the attacker’s page.
-> What Happens: In reality, the user is actually clicking on the invisible iframe that contains the banking page. They might unintentionally trigger actions on the banking site, like transferring money or changing their account settings.

4. Brute-Force Attack Example
-> What It Is: A Brute-Force Attack is when an attacker attempts to guess the correct credentials (like a password) by trying many possible combinations until they find the correct one.

Example:
-> The Attacker's Goal: The attacker wants to gain unauthorized access to a user's account, for example, the user’s bank account.

-> How It Works:
-> The attacker knows the username (e.g., "victim123") but not the password.
-> Using automated tools, the attacker repeatedly tries different passwords for the account, for example:
-> Password attempt 1: password123
-> Password attempt 2: 123456
-> Password attempt 3: victim123
-> Password attempt 4: qwerty

And so on, until the correct password is found.

-> How It Looks to the User: The attacker might perform hundreds of thousands or even millions of attempts per second, which can eventually crack weak passwords.

-> Attack's Success: Once the attacker guesses the correct password, they can log into the victim’s account and gain access to sensitive information, such as personal data or financial records.

-> How to Prevent Brute-Force Attacks:

a. Rate Limiting:
Limit the number of failed login attempts within a certain time frame (e.g., 5 attempts per minute). After exceeding this limit, block the IP address or enforce a longer delay before the next attempt.

b. CAPTCHA:
Use CAPTCHA challenges after a certain number of failed login attempts. This helps to ensure that it's a human attempting the login rather than a bot performing automated attacks.

c. Account Lockout:
Temporarily lock an account after a set number of failed login attempts. For example, lock the account for 10 minutes after 5 failed login attempts.

d. Multi-Factor Authentication (MFA):
Use MFA to add an extra layer of security. Even if the attacker manages to guess the password, they will still need access to the second factor (e.g., a phone or hardware token).

e. Strong Passwords:
Encourage users to use strong, unique passwords (e.g., a combination of uppercase, lowercase letters, numbers, and special characters). Use a password strength checker and enforce password complexity rules.

5. Password Handling: Secure password storage using hashing (e.g., BCrypt).

6. Integration with Spring Boot: Auto-configuration with sensible defaults.

7. JWT (JSON Web Token)


Imnport Notes
############################
Stateless: User details are not stored at the server side. Hence every every request we have to perform authention

Statefull: User details are  stored at the server side. Once the use perform login, Server will generate SessionId, One Copy of session will be kept at server side & another copy is given to the client, so that for subsequent request we can authenticate the user by sending seesionId with the request to server. When session Id matches you will get the respsone

---------------------------------------------------------------------------------

Advantages of JWT Token
#########################
-> Stateless Communication
-> This performs Authentication of subsequent request made post login was successful
-> Highly Secured
-> Set Expiry time for token
-> Securing All Microservice can be made easy with JWT Token

Architecture of JWT Token
###############################
Header.PayLoad.Signature

Explanation of The Architecture

What is header?
Answer: ALGORITHM & TOKEN TYPE

Example:
{
  "alg": "HS256",
  "typ": "JWT"
}

What is PayLoad?
Answer:
-> For which user token is generated (User Details)
-> Who has generated this token (Issuer)
-> Expiry Time Of Token?
{
  "sub": "1234567890",
  "name": "John Doe",
  "iat": 1516239022
}

What is Signature?
Answer: Secret key 



🔐 Spring Security Login Flow (Role-based Authentication):
***********************************************************

[1] Postman /login (LoginDto: username/email + password)
     |
     v
[2] UserController.userLogin()
     |
     v
[3] AuthenticationManager.authenticate(
        new UsernamePasswordAuthenticationToken(usernameOrEmail, password)
    )
     |
     v
[4] DaoAuthenticationProvider
     |
     v
[5] CustomUserDetailsService.loadUserByUsername(usernameOrEmail)
     |
     v
[6] CustomUserDetails (implements UserDetails)
     |
     v
[7] AuthenticationManager compares input password (raw)
       with stored password (encoded) via PasswordEncoder
     |
     v
[8] If valid → Authenticated Authentication object
     |
     v
[9] SecurityContextHolder.getContext().setAuthentication(auth)
     |
     v
[10] Access roles via auth.getAuthorities()


Summary :

| Component                    | Responsibility                                    |
| ---------------------------- | ------------------------------------------------- |
| `LoginDto`                   | Input: username/email + password from Postman     |
| `AuthenticationManager`      | Main gateway to trigger Spring Security auth      |
| `DaoAuthenticationProvider`  | Validates credentials via DB                      |
| `UserDetailsService`         | Loads user by username/email                      |
| `UserDetails` (custom class) | Contains username, password, roles                |
| `PasswordEncoder`            | Matches raw password with encoded password in DB  |
| `SecurityContextHolder`      | Stores authentication info for use in app context |







                                              PART :: 1  SECURITY IMPLEMENTATION.
________________________________________________________________________________________________________________________________


STEPS FOR SINGUP ROLE-BASED :
******************************

STEP-1 :

 -> create User entity class :
-------------------------------
@Entity
@Table(name="user")
@Data
@AllArgsConstructor
@NoArgsConstructor
public class User {

    @Id
    @GeneratedValue(strategy = GenerationType.IDENTITY)
    private long id;

    @Column(name = "name", nullable = false)
    private String name;

    @Column(name = "username", nullable = false, unique = true)
    private String username;

    @Column(name = "email", nullable = false, unique = true)
    private String email;

    @Column(name = "password")
    private String password;

    @ElementCollection(fetch = FetchType.EAGER)
    @CollectionTable(name = "user_roles", joinColumns = @JoinColumn(name = "user_id"))
    @Enumerated(EnumType.STRING)
    @Column(name = "role")
    private Set<Roles> roles;

}

-> create Role enum class :
------------------------------
public enum Roles {

    PATIENT,DOCTOR,ADMIN
}

STEP-2 :

-> create user dto class :
---------------------------
@Data
public class UserDTO {

    private long id;

    private String name;

    private String username;

    private String email;

    private String password;

    private Set<Roles> roles;

}

STEP-3 :

-> create controller class :
----------------------------
@RestController
@RequestMapping("/api/v1/auth/")
public class AuthController {

    @Autowired
    private AuthService authService;

    //    http://localhost:8085/api/v1/auth/register
    @PostMapping("/register")
    public ResponseEntity<APIResponse<String>> register(@RequestBody UserDTO dto) {
        APIResponse<String> response = authService.register(dto);
        return new ResponseEntity<>(response, HttpStatusCode.valueOf(response.getStatus()));
    }
}


STEP-4 :

-> create service class :
-------------------------
@Service
public class AuthService {

    @Autowired
    private UserRepository userRepository;

    @Autowired
    private PasswordEncoder passwordEncoder;


    public APIResponse<String> register(UserDTO dto) {

        if (userRepository.existsByUsername(dto.getUsername())) {
            APIResponse<String> response = new APIResponse<>();
            response.setMessage("Registration Failed");
            response.setStatus(500);
            response.setData("User with username exists");
            return response;
        }
        if (userRepository.existsByEmail(dto.getEmail())) {
            APIResponse<String> response = new APIResponse<>();
            response.setMessage("Registration Failed");
            response.setStatus(500);
            response.setData("User with Email Id exists");
            return response;
        }

        User user = new User();
        BeanUtils.copyProperties(dto, user);
        user.setPassword(passwordEncoder.encode(dto.getPassword()));
        userRepository.save(user);

        APIResponse<String> response = new APIResponse<>();
        response.setMessage("Registration Done");
        response.setStatus(201);
        response.setData("User is registered");

        return response;
    }
}


STEP-5 :

-> create repository :
-----------------------
public interface UserRepository extends JpaRepository<User,Long> {
    boolean existsByUsername(String username);
    boolean existsByEmail(String email);
}

STEP - 6 :

-> create config class for by passing url :
-------------------------------------------
@Configuration
@EnableWebSecurity
public class AppSecurityConfig {

    @Bean
    public PasswordEncoder getEncoder() {
        return new BCryptPasswordEncoder();
    }


    String[] publicEndpoints = {
            "/api/v1/auth/register",
            "/api/v1/auth/login",
            "/api/v1/auth/update-password",
            "/v3/api-docs/**",
            "/swagger-ui/**",
            "/swagger-ui.html",
            "/swagger-resources/**",
            "/webjars/**",
            "/actuator/**",
            "/eureka/**"
    };

    @Bean
    public SecurityFilterChain securityConfig(HttpSecurity http) throws Exception{

        http.
                csrf(cr->cr.disable())
                .authorizeHttpRequests( req -> req
                        .requestMatchers(publicEndpoints).permitAll()
                        .anyRequest().authenticated()
                );

        return http.build();
    }

}


Note : test through postman
-> url : http://localhost:8085/api/v1/auth/register
-> body :
{
  "name": "rahul",
  "username": "rahulkumar",
  "email": "rahul@example.com",
  "password": "rahul123",
  "roles": ["ADMIN", "PATIENT"]
}
-> Auth Type : Basic Auth





STEPS FOR UPDATE PASSWORD :
***************************


STEP - 1 :

-> Create dto class :
-----------------------
@Data
public class UpdatePasswordDto {

    private String email;
    private String username;
    private String newPassword;
    private String oldPassword;

}

STEP-2 :
-> Add below code in AuthController:
------------------------------------
    @PutMapping("/update-password")
    public ResponseEntity<APIResponse<String>> updatePassword(@RequestBody UpdatePasswordDTO updatePasswordDto){
        APIResponse<String> response = authService.setNewPassword(updatePasswordDto);
        return new ResponseEntity<>(response, HttpStatusCode.valueOf(response.getStatus()));
    }

STEP-3 :
-> Add below code in AuthService class :
----------------------------------------
public APIResponse<String> setNewPassword(UpdatePasswordDTO updatePasswordDto) {
        if(!userRepository.existsByUsername(updatePasswordDto.getUsername())) {
            APIResponse<String> response = new APIResponse<>();
            response.setMessage("Failed");
            response.setStatus(500);
            response.setData("User with username doesnot exists");
            return response;
        }
        if(!userRepository.existsByEmail(updatePasswordDto.getEmail())) {
            APIResponse<String> response = new APIResponse<>();
            response.setMessage("Failed");
            response.setStatus(500);
            response.setData("User with Email Id does not exists");
            return response;
        }

        User user = userRepository.findByEmail(updatePasswordDto.getEmail());

        if(BCrypt.checkpw(updatePasswordDto.getOldPassword(), user.getPassword())) {
            user.setPassword(passwordEncoder.encode(updatePasswordDto.getNewPassword()));
            userRepository.save(user);
            APIResponse<String> response = new APIResponse<>();
            response.setMessage("Done");
            response.setStatus(200);
            response.setData("User password is updated");
            return response;
        }

        return null;
    }


Note : test through postman
-> url : http://localhost:8085/api/v1/auth/update-password
-> body :
{
    "email": "rahul@example.com",
    "username": "rahulkumar",
    "newPassword": "rahul246",
    "oldPassword" : "rahul123"
}
-> Auth Type : Basic Auth






STEPS FOR LOGIN ROLE-BASED :
******************************

STEP - 1 :

-> create login dto class :
---------------------------
@Data
public class LoginDto {
    private String usernameOrEmail;
    private String password;
}

STEP-2 :
-> add below code in AuthController :
-------------------------------------
 @PostMapping("/login")
    public ResponseEntity<APIResponse<String>> loginCheck(@RequestBody LoginDto loginDto) {
        APIResponse<String> response = new APIResponse<>();

        UsernamePasswordAuthenticationToken token =
                new UsernamePasswordAuthenticationToken(loginDto.getUsernameOrEmail(), loginDto.getPassword());

        try {
            Authentication authenticate = authenticationManager.authenticate(token);

            if (authenticate.isAuthenticated()) {
                response.setMessage("Login Successful");
                response.setStatus(200);
                response.setData("Login success. Session started.");
                return new ResponseEntity<>(response, HttpStatus.OK);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        response.setMessage("Failed");
        response.setStatus(401);
        response.setData("Un-Authorized Access");
        return new ResponseEntity<>(response, HttpStatus.UNAUTHORIZED);
    }


STEP-3 :
-> create bean of AuthenticationManager in Config class :
------------------------------------------------------------
   @Bean
    public AuthenticationManager authenticationManager(AuthenticationConfiguration config) throws Exception {
        return config.getAuthenticationManager();//Spring auto-wires authentication provider internally in SecurityFilterChain but needs to tell or manually do here
    }


STEP-4 :
-> create bean of DaoAuthenticationProvider in Config class :
------------------------------------------------------------
    @Bean
    public DaoAuthenticationProvider authenticationProvider(){
        DaoAuthenticationProvider authenticationProvider = new DaoAuthenticationProvider();
        authenticationProvider.setPasswordEncoder(getEncoder());
        authenticationProvider.setUserDetailsService(customUserDetailsService); // custom class
        return authenticationProvider;
    }

STEP-5 :
-> create custom user details-service : 
---------------------------------------
@Service
public class CustomUserDetailsService implements UserDetailsService {

    @Autowired
    private UserRepository userRepository;

    @Override
    public UserDetails loadUserByUsername(String usernameOrEmail) throws UsernameNotFoundException {
        User user = userRepository.findByUsernameOrEmail(usernameOrEmail, usernameOrEmail)
                .orElseThrow(() -> new UsernameNotFoundException("User not found with username or email: " + usernameOrEmail));

        return new CustomUserDetails(user);  // ⬅ wrap the user in a class implementing UserDetails
    }
}


STEP-6 :
-> create cutom user details :
-------------------------------

public class CustomUserDetails implements UserDetails {

    private User user;

    public CustomUserDetails(User user) {
        this.user = user;
    }

    @Override
    public Collection<? extends GrantedAuthority> getAuthorities() {
        return user.getRoles().stream()
                .map(roles -> new SimpleGrantedAuthority("Role_"+roles.name())).collect(Collectors.toList()); // Prefixing "ROLE_" is a common Spring Security convention
    }

    @Override
    public String getPassword() {
        return user.getPassword();
    }

    @Override
    public String getUsername() {
        return user.getUsername();
    }
}


Note : test through postman
-> url: http://localhost:8085/api/v1/auth/login
-> body :
{
    "usernameOrEmail": "rahulkumar",
    "password": "rahul246"
}










                                    PART :: 2  AFTER STORING AUTHENTICATION INFO IN SecurityContextHolder IMPLENTING JWT-TOKEN.
______________________________________________________________________________________________________________________________________________________________________


STEPS FOR GENERATING TOKEN  :
*****************************

STEP-1 :

 -> Add these following dependencies :
---------------------------------------

<!-- JWT API and Utilities -->
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-api</artifactId>
        <version>0.11.5</version>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-impl</artifactId>
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>
    <dependency>
        <groupId>io.jsonwebtoken</groupId>
        <artifactId>jjwt-jackson</artifactId> <!-- or jjwt-gson if you use Gson -->
        <version>0.11.5</version>
        <scope>runtime</scope>
    </dependency>



STEPS-2 :
-> Update login code of AuthController :
----------------------------------------
    // http://localhost:8085/api/v1/auth/login
    @PostMapping("/login")
    public ResponseEntity<APIResponse<String>> loginCheck(@RequestBody LoginDto loginDto) {
        APIResponse<String> response = new APIResponse<>();

        UsernamePasswordAuthenticationToken token =
                new UsernamePasswordAuthenticationToken(loginDto.getUsernameOrEmail(), loginDto.getPassword());

        try {
            Authentication authenticate = authenticationManager.authenticate(token);

            if (authenticate.isAuthenticated()) {
                List<String> roles = authenticate.getAuthorities()
                        .stream()
                        .map(GrantedAuthority::getAuthority)
                        .collect(Collectors.toList());
                String jwtToken = jwtService.generateToken(loginDto.getUsernameOrEmail(), roles);

                response.setMessage("Login Successful");
                response.setStatus(200);
                response.setData(jwtToken);
                return new ResponseEntity<>(response, HttpStatus.OK);
            }
        } catch (Exception e) {
            e.printStackTrace();
        }

        response.setMessage("Failed");
        response.setStatus(401);
        response.setData("Un-Authorized Access");
        return new ResponseEntity<>(response, HttpStatus.UNAUTHORIZED);
    }



STEP-3 :
-> create Custom JwtService class which contains logic for token generation & validation :
------------------------------------------------------------------------------------------
@Service
public class JwtService {

    // convert string key to proper SecretKey
    private static final Key SECRET_KEY = Keys.hmacShaKeyFor("my-super-secret-key-which-is-strong-123456".getBytes());
    private static final long EXPIRATION_TIME = 86400000; // 1 day


    public String generateToken(String usernameOrEmail, List<String> roles) {
        Map<String,Object> claims = new HashMap<>();
        claims.put("roles",roles);

        return Jwts.builder()
        .setClaims(claims)
        .setSubject(usernameOrEmail)
        .setIssuedAt(new Date())
        .setExpiration(new Date(System.currentTimeMillis()+EXPIRATION_TIME))
        .signWith(SECRET_KEY, SignatureAlgorithm.HS256)
        .compact();
    }
}


STEPS FOR VALIDATING TOKEN  :
*****************************

STEP-4 :
-> Add bellow code to validate token :
--------------------------------------
    public String validateTokenAndRetrieveSubject(String token) {
        return Jwts.parserBuilder()
                .setSigningKey(SECRET_KEY)
                .build()
                .parseClaimsJws(token)
                .getBody()
                .getSubject();
    }


STEP-5 :
-> Create JwtFilter extends OncePerRequestFilter :
--------------------------------------------------
@Component
public class JwtFilter extends OncePerRequestFilter {

    @Autowired
    private JwtService jwtService;

    @Autowired
    private CustomerUserDetailsService userDetailsService;

    @Override
    protected void doFilterInternal(HttpServletRequest request,
                                    HttpServletResponse response,
                                    FilterChain filterChain) throws ServletException, IOException {

        String authHeader = request.getHeader("Authorization");
        if (authHeader != null && authHeader.startsWith("Bearer ")) {
            String jwt = authHeader.substring(7);
            String username = jwtService.validateTokenAndRetrieveSubject(jwt);

            if (username != null && SecurityContextHolder.getContext().getAuthentication() == null) {
                var userDetails = userDetailsService.loadUserByUsername(username);
                var authToken = new UsernamePasswordAuthenticationToken(
                        userDetails, null, userDetails.getAuthorities());

                authToken.setDetails(new WebAuthenticationDetailsSource().buildDetails(request));
                SecurityContextHolder.getContext().setAuthentication(authToken);
            }
        }

        filterChain.doFilter(request, response);
    }
}



STEP-6 : 
-> update security-filter-chain method in AppsecurityConfig class:
------------------------------------------------------------------
@Bean
    public SecurityFilterChain securityConfig(HttpSecurity http) throws Exception{

        http.
                csrf(cr->cr.disable())
                .authorizeHttpRequests( req -> req
                        .requestMatchers(publicEndpoints)
                        .permitAll()
                        .requestMatchers("/api/v1/admin/welcome").hasRole("ADMIN")
                        .anyRequest()
                        .authenticated())
                .authenticationProvider(authenticationProvider())
                .addFilterBefore(jwtFilter, UsernamePasswordAuthenticationFilter.class);


        return http.build();
    }















